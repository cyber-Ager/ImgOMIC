# compute_stat_across_simulations.R
compute_stat_across_simulations <- function(df_patient,
FUN = NULL,
sdUS = 3.5,
sdCT = 1.9,
n_sim = 2000,
seed = NULL,
keep_samples = FALSE,
min_diam = 0.1) {
# df_patient: data.frame with Date (numeric), Diam (numeric), CT (0/1 or factor)
# FUN: function(Date, Diam) -> numeric scalar. If NULL, defaults to slope of linear regression.
# sdUS, sdCT: measurement standard deviations for US and CT respectively.
# n_sim: number of Monte Carlo simulations
# seed: optional integer for reproducibility
# keep_samples: if TRUE returns all simulated statistic values (may be large)
# min_diam: enforce positive diameters lower bound to avoid degenerate fits
if (!is.data.frame(df_patient)) stop("df_patient must be a data.frame.")
required_cols <- c("Date","Diam","CT")
if (!all(required_cols %in% names(df_patient))) {
stop("df_patient must contain columns: Date, Diam, CT")
}
if (nrow(df_patient) < 2) stop("Need at least two time points.")
if (any(is.na(df_patient$Date) | is.na(df_patient$Diam) | is.na(df_patient$CT))) {
stop("NA values found in Date, Diam or CT columns.")
}
if (!is.numeric(df_patient$Date) || !is.numeric(df_patient$Diam)) {
stop("Date and Diam must be numeric.")
}
# Normalize CT to numeric 0/1
df_patient$CT <- as.numeric(as.character(df_patient$CT))
if (!all(df_patient$CT %in% c(0,1))) stop("CT column must contain only 0 and 1 (or factors convertible to that).")
# default FUN: slope of linear regression (can be negative, large, etc.)
if (is.null(FUN)) {
FUN <- function(dates, diams) {
# return slope (coef of date). If fit fails (e.g. constant diams) return NA
if (length(unique(diams)) <= 1 || length(unique(dates)) <= 1) return(NA_real_)
fit <- try(stats::lm(diams ~ dates), silent = TRUE)
if (inherits(fit, "try-error")) return(NA_real_)
coef(fit)[["dates"]]
}
} else {
# basic check that FUN is a function
if (!is.function(FUN)) stop("FUN must be a function of two arguments: FUN(dates, diams)")
}
if (!is.null(seed)) set.seed(seed)
n <- nrow(df_patient)
dates <- df_patient$Date
measured <- df_patient$Diam
ctflags <- as.integer(df_patient$CT)
stats_vec <- numeric(n_sim)
# precompute sd per row
sds <- ifelse(ctflags == 1, sdCT, sdUS)
for (i in seq_len(n_sim)) {
# sample plausible true diameters for this iteration
sampled <- rnorm(n, mean = measured, sd = sds)
# enforce physical lower bound to avoid negative diameters
sampled <- pmax(sampled, min_diam)
# evaluate user function robustly
val <- try(FUN(dates, sampled), silent = TRUE)
if (inherits(val, "try-error") || length(val) != 1 || !is.finite(val)) {
stats_vec[i] <- NA_real_
} else {
stats_vec[i] <- as.numeric(val)
}
}
# remove NA entries (optional: warn if many NA)
na_count <- sum(is.na(stats_vec))
if (na_count > 0) {
warning(sprintf("%d/%d simulations produced NA for the statistic (they will be ignored).", na_count, n_sim))
}
stats_valid <- stats_vec[is.finite(stats_vec)]
n_valid <- length(stats_valid)
if (n_valid == 0) stop("All simulations failed to produce a finite statistic.")
mean_stat <- mean(stats_valid)
sd_stat   <- stats::sd(stats_valid)
se_stat   <- sd_stat / sqrt(n_valid)
# 95% empirical CI
ci_lower <- mean_stat - 1.96 * se_stat
ci_upper <- mean_stat + 1.96 * se_stat
res <- list(
mean = mean_stat,
sd = sd_stat,
se = se_stat,
n_sim = n_sim,
n_valid = n_valid,
ci95 = c(lower = ci_lower, upper = ci_upper),
samples = if (keep_samples) stats_valid else NULL
)
return(res)
}
data_multi <- data.frame(
ID = as.factor(c("1", "1", "1", "1", "1", "1",  "2", "2", "2", "2")),
Date = c(2015, 2016, 2017, 2020, 2021, 2024, 2013, 2016, 2018, 2019),
Diam = c(30, 35, 34, 53, 50, 52, 38, 42, 50, 53),
CT = as.factor(c(1, 0, 0, 1, 0, 0, 0, 0, 0, 1))
)
df_patient <- subset(data_multi, ID == "1")
compute_stat_across_simulations(df_patient)
# df_patient: data.frame with Date (numeric), Diam (numeric), CT (0/1 or factor)
# FUN: function(Date, Diam) -> numeric scalar. If NULL, defaults to slope of linear regression.
# sdUS, sdCT: measurement standard deviations for US and CT respectively.
# n_sim: number of Monte Carlo simulations
# seed: optional integer for reproducibility
# keep_samples: if TRUE returns all simulated statistic values (may be large)
# min_diam: enforce positive diameters lower bound to avoid degenerate fits
if (!is.data.frame(df_patient)) stop("df_patient must be a data.frame.")
required_cols <- c("Date","Diam","CT")
if (!all(required_cols %in% names(df_patient))) {
stop("df_patient must contain columns: Date, Diam, CT")
}
if (nrow(df_patient) < 2) stop("Need at least two time points.")
if (any(is.na(df_patient$Date) | is.na(df_patient$Diam) | is.na(df_patient$CT))) {
stop("NA values found in Date, Diam or CT columns.")
}
if (!is.numeric(df_patient$Date) || !is.numeric(df_patient$Diam)) {
stop("Date and Diam must be numeric.")
}
# Normalize CT to numeric 0/1
df_patient$CT <- as.numeric(as.character(df_patient$CT))
if (!all(df_patient$CT %in% c(0,1))) stop("CT column must contain only 0 and 1 (or factors convertible to that).")
# default FUN: slope of linear regression (can be negative, large, etc.)
if (is.null(FUN)) {
FUN <- function(dates, diams) {
# return slope (coef of date). If fit fails (e.g. constant diams) return NA
if (length(unique(diams)) <= 1 || length(unique(dates)) <= 1) return(NA_real_)
fit <- try(stats::lm(diams ~ dates), silent = TRUE)
if (inherits(fit, "try-error")) return(NA_real_)
coef(fit)[["dates"]]
}
} else {
# basic check that FUN is a function
if (!is.function(FUN)) stop("FUN must be a function of two arguments: FUN(dates, diams)")
}
FUN = NULL
FUN = NULL,
sdUS = 3.5,
sdUS = 3.5
sdCT = 1.9
n_sim = 2000
seed = NULL
keep_samples = FALSE
min_diam = 0.1
# keep_samples: if TRUE returns all simulated statistic values (may be large)
# min_diam: enforce positive diameters lower bound to avoid degenerate fits
if (!is.data.frame(df_patient)) stop("df_patient must be a data.frame.")
required_cols <- c("Date","Diam","CT")
if (!all(required_cols %in% names(df_patient))) {
stop("df_patient must contain columns: Date, Diam, CT")
}
if (nrow(df_patient) < 2) stop("Need at least two time points.")
if (any(is.na(df_patient$Date) | is.na(df_patient$Diam) | is.na(df_patient$CT))) {
stop("NA values found in Date, Diam or CT columns.")
}
if (!is.numeric(df_patient$Date) || !is.numeric(df_patient$Diam)) {
stop("Date and Diam must be numeric.")
}
# Normalize CT to numeric 0/1
df_patient$CT <- as.numeric(as.character(df_patient$CT))
if (!all(df_patient$CT %in% c(0,1))) stop("CT column must contain only 0 and 1 (or factors convertible to that).")
# default FUN: slope of linear regression (can be negative, large, etc.)
if (is.null(FUN)) {
FUN <- function(dates, diams) {
# return slope (coef of date). If fit fails (e.g. constant diams) return NA
if (length(unique(diams)) <= 1 || length(unique(dates)) <= 1) return(NA_real_)
fit <- try(stats::lm(diams ~ dates), silent = TRUE)
if (inherits(fit, "try-error")) return(NA_real_)
coef(fit)[["dates"]]
}
} else {
# basic check that FUN is a function
if (!is.function(FUN)) stop("FUN must be a function of two arguments: FUN(dates, diams)")
}
if (!is.null(seed)) set.seed(seed)
# Numbero of entries
n <- nrow(df_patient)
dates <- df_patient$Date
measured <- df_patient$Diam
ctflags <- as.integer(df_patient$CT)
stats_vec <- numeric(n_sim)
# precompute sd per row
sds <- ifelse(ctflags == 1, sdCT, sdUS)
sampled <- rnorm(n, mean = measured, sd = sds)
sampled <- pmax(sampled, min_diam)
a <- c(3, 4, -5, 9)
pmax(a, 0.1)
pmin(aa, 5)
pmin(a, 5)
compute_stat_across_simulations(df_patient, n_sim = 5000)
compute_stat_across_simulations(df_patient, n_sim = 10000)
# compute_stat_across_simulations.R
compute_stat_across_simulations <- function(df_patient,
FUN = NULL,
sdUS = 3.5,
sdCT = 1.9,
n_sim = 2000,
seed = NULL,
keep_samples = FALSE,
min_diam = 0.1) {
# df_patient: data.frame with Date (numeric), Diam (numeric), CT (0/1 or factor)
# FUN: function(Date, Diam) -> numeric scalar. If NULL, defaults to slope of linear regression.
# sdUS, sdCT: measurement standard deviations for US and CT respectively.
# n_sim: number of Monte Carlo simulations
# seed: optional integer for reproducibility
# keep_samples: if TRUE returns all simulated statistic values (may be large)
# min_diam: enforce positive diameters lower bound to avoid degenerate fits
if (!is.data.frame(df_patient)) stop("df_patient must be a data.frame.")
required_cols <- c("Date","Diam","CT")
if (!all(required_cols %in% names(df_patient))) {
stop("df_patient must contain columns: Date, Diam, CT")
}
if (nrow(df_patient) < 2) stop("Need at least two time points.")
if (any(is.na(df_patient$Date) | is.na(df_patient$Diam) | is.na(df_patient$CT))) {
stop("NA values found in Date, Diam or CT columns.")
}
if (!is.numeric(df_patient$Date) || !is.numeric(df_patient$Diam)) {
stop("Date and Diam must be numeric.")
}
# Normalize CT to numeric 0/1
df_patient$CT <- as.numeric(as.character(df_patient$CT))
if (!all(df_patient$CT %in% c(0,1))) stop("CT column must contain only 0 and 1 (or factors convertible to that).")
# default FUN: slope of linear regression (can be negative, large, etc.)
if (is.null(FUN)) {
FUN <- function(dates, diams) {
# return slope (coef of date). If fit fails (e.g. constant diams) return NA
if (length(unique(diams)) <= 1 || length(unique(dates)) <= 1) return(NA_real_)
fit <- try(stats::lm(diams ~ dates), silent = TRUE)
if (inherits(fit, "try-error")) return(NA_real_)
coef(fit)[["dates"]]
}
} else {
# basic check that FUN is a function
if (!is.function(FUN)) stop("FUN must be a function of two arguments: FUN(dates, diams)")
}
if (!is.null(seed)) set.seed(seed)
n <- nrow(df_patient)
dates <- df_patient$Date
measured <- df_patient$Diam
ctflags <- as.integer(df_patient$CT)
stats_vec <- numeric(n_sim)
# precompute sd per row
sds <- ifelse(ctflags == 1, sdCT, sdUS)
for (i in seq_len(n_sim)) {
# sample plausible true diameters for this iteration
sampled <- rnorm(n, mean = measured, sd = sds)
# enforce physical lower bound to avoid negative diameters
sampled <- pmax(sampled, min_diam)
# evaluate user function robustly
val <- try(FUN(dates, sampled), silent = TRUE)
if (inherits(val, "try-error") || length(val) != 1 || !is.finite(val)) {
stats_vec[i] <- NA_real_
} else {
stats_vec[i] <- as.numeric(val)
}
}
# remove NA entries (optional: warn if many NA)
na_count <- sum(is.na(stats_vec))
if (na_count > 0) {
warning(sprintf("%d/%d simulations produced NA for the statistic (they will be ignored).", na_count, n_sim))
}
stats_valid <- stats_vec[is.finite(stats_vec)]
n_valid <- length(stats_valid)
if (n_valid == 0) stop("All simulations failed to produce a finite statistic.")
mean_stat <- mean(stats_valid)
sd_stat   <- stats::sd(stats_valid)
se_stat   <- sd_stat / sqrt(n_valid)
# 95% empirical CI
ci_lower <- mean_stat - 1.96 * se_stat
ci_upper <- mean_stat + 1.96 * se_stat
res <- list(
mean = mean_stat,
sd = sd_stat,
se = se_stat,
n_sim = n_sim,
n_valid = n_valid,
ci95 = c(lower = ci_lower, upper = ci_upper),
samples = if (keep_samples) stats_valid else NULL
)
return(res)
}
data_multi <- data.frame(
ID = as.factor(c("1", "1", "1", "1", "1", "1",  "2", "2", "2", "2")),
Date = c(2015, 2016, 2017, 2020, 2021, 2024, 2013, 2016, 2018, 2019),
Diam = c(30, 35, 34, 53, 50, 52, 38, 42, 50, 53),
CT = as.factor(c(1, 0, 0, 1, 0, 0, 0, 0, 0, 1))
)
df_patient <- subset(data_multi, ID == "2")
compute_stat_across_simulations(df_patient)
# compute_stat_across_simulations.R
compute_stat_across_simulations <- function(df_patient,
FUN = NULL,
sdUS = 3.5,
sdCT = 1.9,
n_sim = 2000,
seed = NULL,
keep_samples = FALSE,
min_diam = 0.1) {
# df_patient: data.frame with Date (numeric), Diam (numeric), CT (0/1 or factor)
# FUN: function(Date, Diam) -> numeric scalar. If NULL, defaults to slope of linear regression.
# sdUS, sdCT: measurement standard deviations for US and CT respectively.
# n_sim: number of Monte Carlo simulations
# seed: optional integer for reproducibility
# keep_samples: if TRUE returns all simulated statistic values (may be large)
# min_diam: enforce positive diameters lower bound to avoid degenerate fits
if (!is.data.frame(df_patient)) stop("df_patient must be a data.frame.")
required_cols <- c("Date","Diam","CT")
if (!all(required_cols %in% names(df_patient))) {
stop("df_patient must contain columns: Date, Diam, CT")
}
if (nrow(df_patient) < 2) stop("Need at least two time points.")
if (any(is.na(df_patient$Date) | is.na(df_patient$Diam) | is.na(df_patient$CT))) {
stop("NA values found in Date, Diam or CT columns.")
}
if (!is.numeric(df_patient$Date) || !is.numeric(df_patient$Diam)) {
stop("Date and Diam must be numeric.")
}
# Normalize CT to numeric 0/1
df_patient$CT <- as.numeric(as.character(df_patient$CT))
if (!all(df_patient$CT %in% c(0,1))) stop("CT column must contain only 0 and 1 (or factors convertible to that).")
# default FUN: slope of linear regression (can be negative, large, etc.)
if (is.null(FUN)) {
FUN <- function(dates, diams) {
# return slope (coef of date). If fit fails (e.g. constant diams) return NA
if (length(unique(diams)) <= 1 || length(unique(dates)) <= 1) return(NA_real_)
fit <- try(stats::lm(diams ~ dates), silent = TRUE)
if (inherits(fit, "try-error")) return(NA_real_)
coef(fit)[["dates"]]
}
} else {
# basic check that FUN is a function
if (!is.function(FUN)) stop("FUN must be a function of two arguments: FUN(dates, diams)")
}
if (!is.null(seed)) set.seed(seed)
n <- nrow(df_patient)
dates <- df_patient$Date
measured <- df_patient$Diam
ctflags <- as.integer(df_patient$CT)
stats_vec <- numeric(n_sim)
# precompute sd per row
sds <- ifelse(ctflags == 1, sdCT, sdUS)
for (i in seq_len(n_sim)) {
# sample plausible true diameters for this iteration
sampled <- rnorm(n, mean = measured, sd = sds)
# enforce physical lower bound to avoid negative diameters
sampled <- pmax(sampled, min_diam)
# evaluate user function robustly
val <- try(FUN(dates, sampled), silent = TRUE)
if (inherits(val, "try-error") || length(val) != 1 || !is.finite(val)) {
stats_vec[i] <- NA_real_
} else {
stats_vec[i] <- as.numeric(val)
}
}
# remove NA entries (optional: warn if many NA)
na_count <- sum(is.na(stats_vec))
if (na_count > 0) {
warning(sprintf("%d/%d simulations produced NA for the statistic (they will be ignored).", na_count, n_sim))
}
stats_valid <- stats_vec[is.finite(stats_vec)]
n_valid <- length(stats_valid)
if (n_valid == 0) stop("All simulations failed to produce a finite statistic.")
mean_stat <- mean(stats_valid)
sd_stat   <- stats::sd(stats_valid)
se_stat   <- sd_stat / sqrt(n_valid)
# 95% empirical CI
ci_lower <- mean_stat - 1.96 * se_stat
ci_upper <- mean_stat + 1.96 * se_stat
res <- list(
mean = mean_stat,
sd = sd_stat,
se = se_stat,
n_sim = n_sim,
n_valid = n_valid,
ci95 = c(lower = ci_lower, upper = ci_upper),
samples = if (keep_samples) stats_valid else NULL
)
return(res)
}
data_multi <- data.frame(
ID = as.factor(c("1", "1", "1", "1", "1", "1",  "2", "2", "2", "2")),
Date = c(2015, 2016, 2017, 2020, 2021, 2024, 2013, 2013.4, 2014, 2014.5),
Diam = c(30, 35, 34, 53, 50, 52, 38, 42, 50, 53),
CT = as.factor(c(1, 0, 0, 1, 0, 0, 0, 0, 0, 1))
)
df_patient <- subset(data_multi, ID == "2")
compute_stat_across_simulations(df_patient)
