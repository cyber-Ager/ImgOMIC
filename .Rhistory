y_limits <- range(c(patientA$Diam, patientB$Diam, linesA$Diam_line, linesB$Diam_line))
# Plot Patient A
pA <- ggplot() +
geom_point(data = patientA, aes(x = Date, y = Diam), color = "#3F51B5", size = 3) +
geom_line(data = linesA, aes(x = Date, y = Diam_line, group = Simulation), color = "#3F51B5", alpha = 0.6) +
labs(title = "Patient A (many time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Plot Patient B
pB <- ggplot() +
geom_point(data = patientB, aes(x = Date, y = Diam), color = "#E91E63", size = 3) +
geom_line(data = linesB, aes(x = Date, y = Diam_line, group = Simulation), color = "#E91E63", alpha = 0.6) +
labs(title = "Patient B (3 time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Combine slope plots side by side
p2 <- pA + pB + plot_annotation(title = "Simulated slopes (velocity) for each patient")
# --- 6. Display plots ----------------------------------------------------------
p1
#| echo = FALSE
library(ggplot2)
library(dplyr)
library(patchwork)
#devtools::load_all()
set.seed(123)
# --- 1. Generate exaggerated synthetic patients --------------------------------
# Patient A: many time points
patientA <- data.frame(
ID = "A",
Date = seq(2015, 2025, by = 1),
Diam = cumsum(rnorm(11, mean = 2.5, sd = 1)) + 30,
CT   = sample(c(0, 1), 11, replace = TRUE)
)
# Patient B: very few time points (3)
patientB <- data.frame(
ID = "B",
Date = c(2016, 2017, 2019),
Diam = c(30, 32, 34),
CT   = sample(c(0, 1), 3, replace = TRUE)
)
df_all <- bind_rows(patientA, patientB)
# --- 2. Define slope function ---------------------------------------------------
vel_fun <- function(dates, diams) {
if (length(unique(dates)) <= 1 || length(unique(diams)) <= 1) return(NA_real_)
fit <- lm(diams ~ dates)
coef(fit)[["dates"]]
}
# --- 3. Compute slopes via simulation (n_sim = 7) ------------------------------
simA <- lapply(1:7, function(seed)
simulate_function_sd(patientA, FUN = vel_fun, n_sim = 1, seed = seed)
)
simB <- lapply(1:7, function(seed)
simulate_function_sd(patientB, FUN = vel_fun, n_sim = 1, seed = seed)
)
# Extract slopes
velsA <- sapply(simA, `[[`, "mean")
velsB <- sapply(simB, `[[`, "mean")
# --- 4. Plot 1: Combined patient trajectories ----------------------------------
# Define line colors for each patient
df_all <- df_all %>%
mutate(line_color = ifelse(ID == "A", "#3F51B5", "#E91E63"))
p1 <- ggplot(df_all, aes(x = Date, y = Diam, color = ID, group = ID)) +
geom_line(aes(color = line_color), linewidth = 1) +
geom_point(aes(shape = factor(CT)), size = 3, fill = "white") +
scale_shape_manual(
name = "CT",
values = c("0" = 16,  # circle for US
"1" = 4)   # cross for CT
) +
labs(
title = "Patient trajectories with modality markers",
subtitle = "Patient A (dense) vs Patient B (sparse)",
x = "Date",
y = "Diameter (mm)"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
# --- 5. Plot 2: Slopes as straight lines with points ----------------------------
# Function to generate lines based on slope for plotting
generate_lines <- function(df_patient, slopes) {
do.call(rbind, lapply(slopes, function(slope) {
data.frame(
Date = df_patient$Date,
Diam_line = df_patient$Diam[1] + slope * (df_patient$Date - df_patient$Date[1]),
Simulation = paste0("sim_", round(slope,2))
)
}))
}
linesA <- generate_lines(patientA, velsA)
linesA$ID <- "A"
linesB <- generate_lines(patientB, velsB)
linesB$ID <- "B"
# Determine common x and y limits
x_limits <- range(c(patientA$Date, patientB$Date))
y_limits <- range(c(patientA$Diam, patientB$Diam, linesA$Diam_line, linesB$Diam_line))
# Plot Patient A
pA <- ggplot() +
geom_point(data = patientA, aes(x = Date, y = Diam), color = "#3F51B5", size = 3) +
geom_line(data = linesA, aes(x = Date, y = Diam_line, group = Simulation), color = "#3F51B5", alpha = 0.6) +
labs(title = "Patient A (many time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Plot Patient B
pB <- ggplot() +
geom_point(data = patientB, aes(x = Date, y = Diam), color = "#E91E63", size = 3) +
geom_line(data = linesB, aes(x = Date, y = Diam_line, group = Simulation), color = "#E91E63", alpha = 0.6) +
labs(title = "Patient B (3 time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Combine slope plots side by side
p2 <- pA + pB + plot_annotation(title = "Simulated slopes (velocity) for each patient")
# --- 6. Display plots ----------------------------------------------------------
p1
#| echo = FALSE
p2
#| echo = FALSE
library(ggplot2)
library(dplyr)
library(patchwork)
#devtools::load_all()
set.seed(123)
# --- 1. Generate exaggerated synthetic patients --------------------------------
# Patient A: many time points
patientA <- data.frame(
ID = "A",
Date = seq(2015, 2025, by = 1),
Diam = cumsum(rnorm(11, mean = 2.5, sd = 1)) + 30,
CT   = sample(c(0, 1), 11, replace = TRUE)
)
# Patient B: very few time points (3)
patientB <- data.frame(
ID = "B",
Date = c(2016, 2017, 2019),
Diam = c(30, 32, 34),
CT   = sample(c(0, 1), 3, replace = TRUE)
)
df_all <- bind_rows(patientA, patientB)
# --- 2. Define slope function ---------------------------------------------------
vel_fun <- function(dates, diams) {
if (length(unique(dates)) <= 1 || length(unique(diams)) <= 1) return(NA_real_)
fit <- lm(diams ~ dates)
coef(fit)[["dates"]]
}
# --- 3. Compute slopes via simulation (n_sim = 7) ------------------------------
simA <- lapply(1:7, function(seed)
simulate_function_sd(patientA, FUN = vel_fun, n_sim = 1, seed = seed)
)
simB <- lapply(1:7, function(seed)
simulate_function_sd(patientB, FUN = vel_fun, n_sim = 1, seed = seed)
)
# Extract slopes
velsA <- sapply(simA, `[[`, "mean")
velsB <- sapply(simB, `[[`, "mean")
# --- 4. Plot 1: Combined patient trajectories ----------------------------------
# Define line colors for each patient
df_all <- df_all %>%
mutate(line_color = ifelse(ID == "A", "#3F51B5", "#E91E63"))
p1 <- ggplot(df_all, aes(x = Date, y = Diam, color = ID, group = ID)) +
geom_line(aes(color = line_color), linewidth = 1) +
geom_point(aes(shape = factor(CT), color = line_color), size = 3, fill = "white") +
scale_shape_manual(
name = "CT",
values = c("0" = 16,  # circle for US
"1" = 4)   # cross for CT
) +
labs(
title = "Patient trajectories with modality markers",
subtitle = "Patient A (dense) vs Patient B (sparse)",
x = "Date",
y = "Diameter (mm)"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
# --- 5. Plot 2: Slopes as straight lines with points ----------------------------
# Function to generate lines based on slope for plotting
generate_lines <- function(df_patient, slopes) {
do.call(rbind, lapply(slopes, function(slope) {
data.frame(
Date = df_patient$Date,
Diam_line = df_patient$Diam[1] + slope * (df_patient$Date - df_patient$Date[1]),
Simulation = paste0("sim_", round(slope,2))
)
}))
}
linesA <- generate_lines(patientA, velsA)
linesA$ID <- "A"
linesB <- generate_lines(patientB, velsB)
linesB$ID <- "B"
# Determine common x and y limits
x_limits <- range(c(patientA$Date, patientB$Date))
y_limits <- range(c(patientA$Diam, patientB$Diam, linesA$Diam_line, linesB$Diam_line))
# Plot Patient A
pA <- ggplot() +
geom_point(data = patientA, aes(x = Date, y = Diam), color = "#3F51B5", size = 3) +
geom_line(data = linesA, aes(x = Date, y = Diam_line, group = Simulation), color = "#3F51B5", alpha = 0.6) +
labs(title = "Patient A (many time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Plot Patient B
pB <- ggplot() +
geom_point(data = patientB, aes(x = Date, y = Diam), color = "#E91E63", size = 3) +
geom_line(data = linesB, aes(x = Date, y = Diam_line, group = Simulation), color = "#E91E63", alpha = 0.6) +
labs(title = "Patient B (3 time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Combine slope plots side by side
p2 <- pA + pB + plot_annotation(title = "Simulated slopes (velocity) for each patient")
# --- 6. Display plots ----------------------------------------------------------
p1
#| echo = FALSE
library(ggplot2)
library(dplyr)
library(patchwork)
#devtools::load_all()
set.seed(123)
# --- 1. Generate exaggerated synthetic patients --------------------------------
# Patient A: many time points
patientA <- data.frame(
ID = "A",
Date = seq(2015, 2025, by = 1),
Diam = cumsum(rnorm(11, mean = 2.5, sd = 1)) + 30,
CT   = sample(c(0, 1), 11, replace = TRUE)
)
# Patient B: very few time points (3)
patientB <- data.frame(
ID = "B",
Date = c(2016, 2017, 2019),
Diam = c(30, 32, 34),
CT   = sample(c(0, 1), 3, replace = TRUE)
)
df_all <- bind_rows(patientA, patientB)
# --- 2. Define slope function ---------------------------------------------------
vel_fun <- function(dates, diams) {
if (length(unique(dates)) <= 1 || length(unique(diams)) <= 1) return(NA_real_)
fit <- lm(diams ~ dates)
coef(fit)[["dates"]]
}
# --- 3. Compute slopes via simulation (n_sim = 7) ------------------------------
simA <- lapply(1:7, function(seed)
simulate_function_sd(patientA, FUN = vel_fun, n_sim = 1, seed = seed)
)
simB <- lapply(1:7, function(seed)
simulate_function_sd(patientB, FUN = vel_fun, n_sim = 1, seed = seed)
)
# Extract slopes
velsA <- sapply(simA, `[[`, "mean")
velsB <- sapply(simB, `[[`, "mean")
# --- 4. Plot 1: Combined patient trajectories ----------------------------------
# Define line colors for each patient
df_all <- df_all %>%
mutate(line_color = ifelse(ID == "A", "#3F51B5", "#E91E63"))
p1 <- ggplot(df_all, aes(x = Date, y = Diam, color = ID, group = ID)) +
geom_line(aes(color = line_color), linewidth = 1) +
geom_point(aes(shape = factor(CT), color = line_color), size = 3, fill = "white") +
scale_shape_manual(
name = "CT",
values = c("0" = 16,  # circle for US
"1" = 4)   # cross for CT
) +
labs(
title = "Patient trajectories with modality markers",
subtitle = "Patient A (dense) vs Patient B (sparse)",
x = "Date",
y = "Diameter (mm)"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
p1 <- ggplot(df_all, aes(x = Date, y = Diam, group = ID)) +
geom_line(aes(color = line_color), linewidth = 1) +
geom_point(aes(shape = factor(CT), color = line_color), size = 3, fill = "white") +
scale_color_identity() +  # use actual color values
scale_shape_manual(
name = "CT",
values = c("0" = 16,  # circle for US
"1" = 4)   # cross for CT
) +
labs(
title = "Patient trajectories with modality markers",
subtitle = "Patient A (dense) vs Patient B (sparse)",
x = "Date",
y = "Diameter (mm)"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
# --- 5. Plot 2: Slopes as straight lines with points ----------------------------
# Function to generate lines based on slope for plotting
generate_lines <- function(df_patient, slopes) {
do.call(rbind, lapply(slopes, function(slope) {
data.frame(
Date = df_patient$Date,
Diam_line = df_patient$Diam[1] + slope * (df_patient$Date - df_patient$Date[1]),
Simulation = paste0("sim_", round(slope,2))
)
}))
}
linesA <- generate_lines(patientA, velsA)
linesA$ID <- "A"
linesB <- generate_lines(patientB, velsB)
linesB$ID <- "B"
# Determine common x and y limits
x_limits <- range(c(patientA$Date, patientB$Date))
y_limits <- range(c(patientA$Diam, patientB$Diam, linesA$Diam_line, linesB$Diam_line))
# Plot Patient A
pA <- ggplot() +
geom_point(data = patientA, aes(x = Date, y = Diam), color = "#3F51B5", size = 3) +
geom_line(data = linesA, aes(x = Date, y = Diam_line, group = Simulation), color = "#3F51B5", alpha = 0.6) +
labs(title = "Patient A (many time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Plot Patient B
pB <- ggplot() +
geom_point(data = patientB, aes(x = Date, y = Diam), color = "#E91E63", size = 3) +
geom_line(data = linesB, aes(x = Date, y = Diam_line, group = Simulation), color = "#E91E63", alpha = 0.6) +
labs(title = "Patient B (3 time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Combine slope plots side by side
p2 <- pA + pB + plot_annotation(title = "Simulated slopes (velocity) for each patient")
# --- 6. Display plots ----------------------------------------------------------
p1
#| echo = FALSE
library(ggplot2)
library(dplyr)
library(patchwork)
#devtools::load_all()
set.seed(123)
# --- 1. Generate exaggerated synthetic patients --------------------------------
# Patient A: many time points
patientA <- data.frame(
ID = "A",
Date = seq(2015, 2025, by = 1),
Diam = cumsum(rnorm(11, mean = 2.5, sd = 1)) + 30,
CT   = sample(c(0, 1), 11, replace = TRUE)
)
# Patient B: very few time points (3)
patientB <- data.frame(
ID = "B",
Date = c(2016, 2017, 2019),
Diam = c(30, 32, 34),
CT   = sample(c(0, 1), 3, replace = TRUE)
)
df_all <- bind_rows(patientA, patientB)
# --- 2. Define slope function ---------------------------------------------------
vel_fun <- function(dates, diams) {
if (length(unique(dates)) <= 1 || length(unique(diams)) <= 1) return(NA_real_)
fit <- lm(diams ~ dates)
coef(fit)[["dates"]]
}
# --- 3. Compute slopes via simulation (n_sim = 7) ------------------------------
simA <- lapply(1:7, function(seed)
simulate_function_sd(patientA, FUN = vel_fun, n_sim = 1, seed = seed)
)
simB <- lapply(1:7, function(seed)
simulate_function_sd(patientB, FUN = vel_fun, n_sim = 1, seed = seed)
)
# Extract slopes
velsA <- sapply(simA, `[[`, "mean")
velsB <- sapply(simB, `[[`, "mean")
# --- 4. Plot 1: Combined patient trajectories ----------------------------------
# Define line colors for each patient
df_all <- df_all %>%
mutate(line_color = ifelse(ID == "A", "#3F51B5", "#E91E63"))
p1 <- ggplot(df_all, aes(x = Date, y = Diam, group = ID)) +
geom_line(aes(color = line_color), linewidth = 1) +
geom_point(aes(shape = factor(CT), color = line_color), size = 3, fill = "white") +
scale_color_identity() +  # use actual color values
scale_shape_manual(
name = "CT",
values = c("0" = 16,  # circle for US
"1" = 4)   # cross for CT
) +
labs(
title = "Patient trajectories with modality markers",
subtitle = "Patient A (dense) vs Patient B (sparse)",
x = "Date",
y = "Diameter (mm)"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
# --- 5. Plot 2: Slopes as straight lines with points ----------------------------
# Function to generate lines based on slope for plotting
generate_lines <- function(df_patient, slopes) {
do.call(rbind, lapply(slopes, function(slope) {
data.frame(
Date = df_patient$Date,
Diam_line = df_patient$Diam[1] + slope * (df_patient$Date - df_patient$Date[1]),
Simulation = paste0("sim_", round(slope,2))
)
}))
}
linesA <- generate_lines(patientA, velsA)
linesA$ID <- "A"
linesB <- generate_lines(patientB, velsB)
linesB$ID <- "B"
# Determine common x and y limits
x_limits <- range(c(patientA$Date, patientB$Date))
y_limits <- range(c(patientA$Diam, patientB$Diam, linesA$Diam_line, linesB$Diam_line))
# Plot Patient A
pA <- ggplot() +
geom_point(data = patientA, aes(x = Date, y = Diam), color = "#3F51B5", size = 3) +
geom_line(data = linesA, aes(x = Date, y = Diam_line, group = Simulation), color = "#3F51B5", alpha = 0.6) +
labs(title = "Patient A (many time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Plot Patient B
pB <- ggplot() +
geom_point(data = patientB, aes(x = Date, y = Diam), color = "#E91E63", size = 3) +
geom_line(data = linesB, aes(x = Date, y = Diam_line, group = Simulation), color = "#E91E63", alpha = 0.6) +
labs(title = "Patient B (3 time points)", x = "Date", y = "Diameter (mm)") +
coord_cartesian(xlim = x_limits, ylim = y_limits) +
theme_minimal(base_size = 14)
# Combine slope plots side by side
p2 <- pA + pB + plot_annotation(title = "Simulated slopes (velocity) for each patient")
# --- 6. Display plots ----------------------------------------------------------
p1
#| echo = FALSE
p2
#| echo = FALSE
# Patient B
patientB <- data.frame(
ID = "B",
Date = c(2016, 2017, 2019),
Diam = c(30, 32, 34),
CT   = c(0, 0, 0)
)
# Patient B1
patientB1 <- data.frame(
ID = "B1",
Date = c(2016, 2017, 2019, 2020, 2021, 2022),
Diam = c(30, 32, 34, 36, 42, 52),
CT   = c(0, 0, 0, 0, 0, 0)
)
# Patient B2
patientB2 <- data.frame(
ID = "B2",
Date = c(2016, 2017, 2019, 2020, 2021, 2022),
Diam = c(30, 32, 34, 33, 35, 34),
CT   = c(0, 0, 0, 0, 0, 0)
)
# Combine all
df_all <- bind_rows(patientB, patientB1, patientB2)
# Define line type per patient
df_all <- df_all %>%
mutate(
line_type = ifelse(ID == "B", "solid", "dashed")
)
# Plot
ggplot(df_all, aes(x = Date, y = Diam, color = ID, group = ID)) +
geom_line(aes(linetype = line_type), color = "#E91E63", linewidth = 1) +
geom_point(aes(shape = factor(CT)), color = "#E91E63", size = 3, fill = "white") +
scale_linetype_identity() + # use the line_type column directly
labs(
title = "Patient trajectories with modality markers",
subtitle = "Patient B1 solid, others dashed",
x = "Date",
y = "Diameter (mm)"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "none")
library(ImgOMIC)
# Simulate patient data
df_patient <- data.frame(
Date = c(2016, 2017, 2018, 2019, 2020),
Diam = c(30, 33, 35, 36, 39),
CT   = c(1, 0, 1, 0, 1)
)
df_test <- read.table("README_data/Tutorial_table.csv", header = TRUE, sep = ",")
# Compute measurement precision
res_precision <- measure_precision(df_test)
res_precision
# Correct diameters
res_corrected <- correct_diameter_single(df_patient)
res_corrected$curves[[1]]
library(ImgOMIC)
# Simulate patient data
df_patient <- data.frame(
Date = c(2016, 2017, 2018, 2019, 2020),
Diam = c(30, 33, 35, 36, 39),
CT   = c(1, 0, 1, 0, 1)
)
df_test <- read.table("README_data/Tutorial_table.csv", header = TRUE, sep = ",")
# Compute measurement precision
res_precision <- measure_precision(df_test)
res_precision
# Correct diameters
res_corrected <- correct_diameter_single(df_patient)
res_corrected$curves[[1]]
library(ImgOMIC)
# Simulated patient data
df_test <- read.table("README_data/Tutorial_table.csv", header = TRUE, sep = ",")
# Compute measurement precision
res_precision <- measure_precision(df_test)
res_precision
# Simulate patient data
df_patient <- data.frame(
Date = c(2016, 2017, 2018, 2019, 2020),
Diam = c(30, 35, 32, 36, 39),
CT   = c(1, 0, 1, 0, 1)
)
# Correct diameters
res_corrected <- correct_diameter_single(df_patient)
res_corrected$curves[[1]]
#| label: tbl-input_table
#| tbl-cap: "First view of Input data table."
#| warning: false
#|
# Load the testing data
df_test <- read.table("../README_data/Tutorial_table.csv", header = TRUE, sep = ",")
knitr::kable(head(df_test))
render("vignettes/documentation.Rmd", output_format = "html_document")
library(rmarkdown)
render("vignettes/documentation.Rmd", output_format = "html_document")
