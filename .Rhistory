df_measure <- tb %>%
dplyr::select(miRNA, data)%>%
# Remove diff and n column from the data dataframe
dplyr::mutate(data = purrr::map(data, ~ .x %>% dplyr::select(-diff, -n))) %>%
tidyr::unnest(data) %>%
tidyr::pivot_wider(names_from = miRNA, values_from = mn)%>%
dplyr::arrange(Sample.Name, date)
# Add the variable nmiRNA to later save the information of the counts used for
# the calculation of the mean value (This would be important in order to
# calculate the real variability of that measurement)
tb$nmiRNA <- paste0("n_", tb$miRNA)
# Save the n_miRNA value
df_n <- tb%>%
dplyr::select(nmiRNA, data)%>%
# Remove diff and n column from the data dataframe
dplyr::mutate(data = purrr::map(data, ~ .x %>% dplyr::select(-diff, -mn))) %>%
tidyr::unnest(data) %>%
tidyr::pivot_wider(names_from = nmiRNA, values_from = n)%>%
dplyr::arrange(Sample.Name, date)%>%
dplyr::select(-Sample.Name, -date)
# Merge both dataframes
df_measure <- cbind(df_measure, df_n)
normalized_measure <- function (tb, fun){
# save the variable names
vars <- all.vars(fun)
# Sort the var names ascending alphabetically
vars <- sort(vars, decreasing = FALSE)
df_measure <- tb %>%
dplyr::select(miRNA, data)%>%
# Remove diff and n column from the data dataframe
dplyr::mutate(data = purrr::map(data, ~ .x %>% dplyr::select(-diff, -n))) %>%
tidyr::unnest(data) %>%
tidyr::pivot_wider(names_from = miRNA, values_from = mn)%>%
dplyr::arrange(Sample.Name, date)
# Add the variable nmiRNA to later save the information of the counts used for
# the calculation of the mean value (This would be important in order to
# calculate the real variability of that measurement)
tb$nmiRNA <- paste0("n_", tb$miRNA)
# Save the n_miRNA value
df_n <- tb%>%
dplyr::select(nmiRNA, data)%>%
# Remove diff and n column from the data dataframe
dplyr::mutate(data = purrr::map(data, ~ .x %>% dplyr::select(-diff, -mn))) %>%
tidyr::unnest(data) %>%
tidyr::pivot_wider(names_from = nmiRNA, values_from = n)%>%
dplyr::arrange(Sample.Name, date)%>%
dplyr::select(-Sample.Name, -date)
# Merge both dataframes
df_measure <- cbind(df_measure, df_n)
derivatives <- lapply(vars, function(var) D(fun, var))
# Ensure that the position of the miRNAs in the tibble is the same as in the "vars"
tb <- tb %>%
dplyr::arrange(miRNA)
# Get the relative error values for each var
RMS <- as.numeric(tb$RMS[tb$miRNA %in% vars])/(100)
MAD <- as.numeric(tb$MAD[tb$miRNA %in% vars])/(100)
# create the Expression for error propagation
error_prop_rms <- 0
error_prop_mad <- 0
for (i in seq_along(derivatives)) {
# Create the expression part by part
term_rms <- substitute(der^2 * (err/sqrt(n_val)*val)^2, list(der = derivatives[[i]], err = RMS[i], val = str2lang(vars[i]), n_val = str2lang(paste0("n_",vars[i]))))
error_prop_rms <- substitute(a + b, list(a = error_prop_rms, b = term_rms))
term_mad <- substitute(der^2 * (err/sqrt(n_val)*val)^2, list(der = derivatives[[i]], err = MAD[i], val = str2lang(vars[i]), n_val = str2lang(paste0("n_",vars[i]))))
error_prop_mad <- substitute(a + b, list(a = error_prop_mad, b = term_mad))
}
error_prop_rms <- substitute(sqrt(x), list(x = error_prop_rms))
error_prop_mad <- substitute(sqrt(x), list(x = error_prop_mad))
apply_equation <- function(...) {
# It is neccessary to have a df with the mirna names in the columns
# Capture the inputs in a list
inputs <- list(...)
# Evaluate the expression, mapping inputs to x1, x2, ...
res <- eval(fun[[1]], envir = inputs)
rms <- eval(do.call(substitute, list(error_prop_rms, inputs)))
mad <- eval(do.call(substitute, list(error_prop_mad, inputs)))
return(c(res, rms, mad))
}
# Aplly the function in the dataframe
results <- do.call(mapply, c(FUN = apply_equation, as.list(df_measure)))
rownames(results) <- c("measure", "RMS_error", "MAD_error")
# Result have 3 rows, one with the mean value and then the RMS and MAD values.
# The column names are the IDs
# Reshape the results
results2 <- as.data.frame(results) %>%
tibble::rownames_to_column("metric") %>%   # Move row names to a column called "metric"
tidyr::pivot_longer(-metric, names_to = "ID", values_to = "value") %>%
# Pivot to long format, the column names goes to ID, and values are distributed.
# The measure type is defined in metric column (measure, rms or mad)
# And the value in value column
tidyr::pivot_wider(names_from = metric, values_from = value)
return(results2)
}
tb <- tb_diff
fun <- norm_mir100_eq
# save the variable names
vars <- all.vars(fun)
# Sort the var names ascending alphabetically
vars <- sort(vars, decreasing = FALSE)
df_measure <- tb %>%
dplyr::select(miRNA, data)%>%
# Remove diff and n column from the data dataframe
dplyr::mutate(data = purrr::map(data, ~ .x %>% dplyr::select(-diff, -n))) %>%
tidyr::unnest(data) %>%
tidyr::pivot_wider(names_from = miRNA, values_from = mn)%>%
dplyr::arrange(Sample.Name, date)
# Add the variable nmiRNA to later save the information of the counts used for
# the calculation of the mean value (This would be important in order to
# calculate the real variability of that measurement)
tb$nmiRNA <- paste0("n_", tb$miRNA)
# Save the n_miRNA value
df_n <- tb%>%
dplyr::select(nmiRNA, data)%>%
# Remove diff and n column from the data dataframe
dplyr::mutate(data = purrr::map(data, ~ .x %>% dplyr::select(-diff, -mn))) %>%
tidyr::unnest(data) %>%
tidyr::pivot_wider(names_from = nmiRNA, values_from = n)%>%
dplyr::arrange(Sample.Name, date)%>%
dplyr::select(-Sample.Name, -date)
# Merge both dataframes
df_measure <- cbind(df_measure, df_n)
derivatives <- lapply(vars, function(var) D(fun, var))
# Ensure that the position of the miRNAs in the tibble is the same as in the "vars"
tb <- tb %>%
dplyr::arrange(miRNA)
# Get the relative error values for each var
RMS <- as.numeric(tb$RMS[tb$miRNA %in% vars])/(100)
MAD <- as.numeric(tb$MAD[tb$miRNA %in% vars])/(100)
error_prop_rms <- 0
error_prop_mad <- 0
for (i in seq_along(derivatives)) {
# Create the expression part by part
term_rms <- substitute(der^2 * (err/sqrt(n_val)*val)^2, list(der = derivatives[[i]], err = RMS[i], val = str2lang(vars[i]), n_val = str2lang(paste0("n_",vars[i]))))
error_prop_rms <- substitute(a + b, list(a = error_prop_rms, b = term_rms))
term_mad <- substitute(der^2 * (err/sqrt(n_val)*val)^2, list(der = derivatives[[i]], err = MAD[i], val = str2lang(vars[i]), n_val = str2lang(paste0("n_",vars[i]))))
error_prop_mad <- substitute(a + b, list(a = error_prop_mad, b = term_mad))
}
error_prop_rms <- substitute(sqrt(x), list(x = error_prop_rms))
error_prop_mad <- substitute(sqrt(x), list(x = error_prop_mad))
apply_equation <- function(...) {
# It is neccessary to have a df with the mirna names in the columns
# Capture the inputs in a list
inputs <- list(...)
# Evaluate the expression, mapping inputs to x1, x2, ...
res <- eval(fun[[1]], envir = inputs)
rms <- eval(do.call(substitute, list(error_prop_rms, inputs)))
mad <- eval(do.call(substitute, list(error_prop_mad, inputs)))
return(c(res, rms, mad))
}
# Aplly the function in the dataframe
results <- do.call(mapply, c(FUN = apply_equation, as.list(df_measure)))
rownames(results) <- c("measure", "RMS_error", "MAD_error")
# Reshape the results
results2 <- as.data.frame(results) %>%
tibble::rownames_to_column("metric") %>%   # Move row names to a column called "metric"
tidyr::pivot_longer(-metric, names_to = "ID", values_to = "value") %>%
# Pivot to long format, the column names goes to ID, and values are distributed.
# The measure type is defined in metric column (measure, rms or mad)
# And the value in value column
tidyr::pivot_wider(names_from = metric, values_from = value)
View(results2)
View(tb[[2]][[1]])
setwd("~/Tesis_AAA_Ager/AAA-Thesis-Packages/ImgOMIC")
load_all(".")
library(devtools)
library(roxygen2)
load_all(".")
roxygenise()
?error_propagation
#| label: tbl-tabs
#| tbl-cap: "First view of TABS data table."
#| warning: false
library(an9elproject)
library(knitr)
library(gridExtra)
tb <- get_project('tabs') # data is loaded
functionals <- tb$functionals # The functions are saved
tb2 <- functionals$preprocessing_growth(tb) # growth is preprocessed
kable(head(tb2$data))
#| label: fig-corr
#| fig-cap: "Correlation plot between miRNAs"
#| warning: false
#| echo: false
library(GGally)
tb_cor <- tb2$data %>%
dplyr::select(mir100, mir16, mir486, mir92a)
ggpairs(tb_cor)
#| warning: false
# Load miRNA dataframe with plate information
df_mirna <- read.table("Datasets/miR100_miR3667_and_controls_240417.txt", header = TRUE, sep = "\t")
# Plot the first rows
head(df_mirna)
dim(df_mirna) # Dimensions of the matrix
length(unique(df_mirna$Sample.Name)) # Number of unique IDs
sum(is.na(df_mirna)) # Number of NAs in the matrix
#| label: fig-NAplot
#| fig-cap: "NA plot of the qPCR results database"
#| warning: false
library(ggplot2)
library(reshape2)
# Create a logical matrix of the NA values
na_matrix <- is.na(df_mirna)
# Convert the matrix into a long format dataframe for ggplot2
na_df <- melt(na_matrix)
# Plot using ggplot2
ggplot(na_df, aes(Var2, Var1)) +
geom_tile(aes(fill = value), color = "white") +
scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
labs(x = "Columns", y = "Rows", fill = "NA Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
#| warning: false
#| label: tbl-mirnafreq
#| tbl-cap: "Count of samples with the same miRNA quantification frequency."
# Made a summary table with the counts of no-NA values in the miRNA columns for each subject.
df_mirna_summary <- df_mirna %>%
dplyr::group_by(Sample.Name)%>%
dplyr::summarise(
freq_mir100 = sum(!is.na(Quantity_mir100)),
freq_mir16 = sum(!is.na(Quantity_mir16)),
freq_mir486 = sum(!is.na(Quantity_mir486)),
freq_mir92 = sum(!is.na(Quantity_mir92))
)
# Count the values with the same amount of miRNA measurements
df_mirna_freq <- df_mirna_summary %>%
dplyr::count(freq_mir100, freq_mir16, freq_mir486, freq_mir92, name = "miRNA_count")
kable(df_mirna_freq)
# First I correct the incorrect name from the dataset
df_mirna <- df_mirna %>%
dplyr::rename(Efficiency_mir100 = Efficiency_mirr100)
#| label: fig-mirnaArray
#| fig-cap: "miRNA distribution in the qPCR plates."
#| warning: false
# Reshape the df_mirna table (It works in all the tables where the first two columns are for name and table)
# If I put it as a function I can just ask for the columns where the miRNA information starts
df_mirna_rs <- df_mirna %>%
tidyr::pivot_longer(
cols = 3:length(colnames(df_mirna)),
names_to = c(".value", "miRNA"),
names_pattern = "(Well|Plate|Quantity|Efficiency)_(mir\\d+)"
)%>%
dplyr::filter(!is.na(Quantity))
# Now i convert the well location information to cartesian coordinates:
# Extract the letter and number parts
# Remove the number part and get the letter
df_mirna_rs$letters <- gsub("[0-9]", "", df_mirna_rs$Well)
# Remove the upper-case letter part and get the number
df_mirna_rs$numbers <- gsub("[A-Z]", "", df_mirna_rs$Well)
# Convert the letter part to a numeric value based on its position in the alphabet (taking into account that they can be more than one letter AB, BB...)
df_mirna_rs$Wellx <- sapply(df_mirna_rs$letters, function(x) {
sum((match(strsplit(x, "")[[1]], LETTERS)) * 26^(nchar(x):1 - 1))
})
# strsplit(x, "")[[1]] -> separates the characters and takes the first vector of the list element AB -> c(A,B) (without the [[1]] it would return a list witrh different vector, in this case we would have just one vector anyways)
# nchar(x):1 -> generates a vector from the number of characers to 1 (in case of having AB c(2,1) in case of haing GGG c(3, 2, 1))
# Convert the number part to numeric
df_mirna_rs$Welly <- as.numeric(df_mirna_rs$numbers)
ggplot(df_mirna_rs, aes(Wellx, Welly))+
geom_point(aes(colour = factor(miRNA)))+
facet_wrap(~Plate)
# Create the vector combining the plate and well infoprmation
WellPlate <- paste0(df_mirna_rs$Plate, df_mirna_rs$Well)
c (length(WellPlate),
length(unique(WellPlate))) # Compare the length of the different vectors: the initial dataset, and the vector with the unique values from the Well Plate vector. All of them must have the same value
#| warning: false
#| label: tbl-repeatedWell
#| tbl-cap: "Table with the information of the samples with the same plate positions."
df_repeats <- df_mirna_rs%>%
dplyr::mutate(PlateWell = paste0(Plate, Well))%>%
dplyr::group_by(PlateWell)%>%
dplyr::filter(dplyr::n() > 1)%>%
dplyr::ungroup()%>%
dplyr::arrange(PlateWell)
# Print table
kable((df_repeats)%>%
dplyr::select(Sample.Name, date, miRNA, Well, Plate, Quantity))
#| warning: false
#| label: fig-repeatedpos
#| fig-cap: "Plate position of the repeated samples."
ggplot(df_repeats, aes(Wellx, Welly))+
geom_point(aes(colour = factor(miRNA)))+
xlim(1, 16)+
facet_wrap(~Plate)
#| warning: false
#| label: fig-arraypos
#| fig-cap: "Sample Names distribution on the miRNA arrays."
# We separate the sample name by groups
df_mirna_rs2 <- df_mirna_rs %>%
dplyr::mutate(NameNumber = substr(Sample.Name , start = nchar(Sample.Name) - 2 , stop = nchar(Sample.Name)))%>%
dplyr::mutate(NameGroup = gsub('.{3}$', '', Sample.Name))
df_mirna_rs2$NameNumber <- as.numeric(df_mirna_rs2$NameNumber)
df_mirna_rs2$NameGroup <- as.factor(df_mirna_rs2$NameGroup)
# Plot the arrayt based on name group and name number
ggplot(df_mirna_rs2, aes(Wellx, Welly))+
geom_point(aes(colour = NameNumber, shape = NameGroup), size = 3)+
scale_color_gradient(low="blue", high="red")+
facet_wrap(~Plate)
#| warning: false
#| label: fig-arrayrows
#| fig-cap: "Sample Names distribution on the plate rows with a repetition and plates row with gaps."
plate1_repeat <- ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 1)%>%dplyr::filter(Welly == 5),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line()+ geom_point()+ylim(c(0, 120))+ ggtitle("Plate 1 Row 5")
plate2_hole <-ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 2)%>%dplyr::filter(Welly == 5),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line() + geom_point()+ylim(c(0, 120))+ ggtitle("Plate 2 Row 5")
plate2_repeat <- ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 2)%>%dplyr::filter(Welly == 3),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line()+ geom_point()+ylim(c(0, 120))+ ggtitle("Plate 2 Row 3")
plate4_hole <-ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 4)%>%dplyr::filter(Welly == 3),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line() + geom_point()+ylim(c(0, 120))+ ggtitle("Plate 4 Row 3")
grid.arrange(plate1_repeat, plate2_hole ,plate2_repeat, plate4_hole, ncol=2, nrow=2)
#| warning: false
#| label: fig-arrayrows-corrected
#| fig-cap: "Sample Names distribution on the plate rows with a repetition and plates row with gaps."
# Correct the Plate values
df_mirna_rs2$Plate <- replace(df_mirna_rs2$Plate, df_mirna_rs2$Sample.Name == "SP5005", 2)
df_mirna_rs2$Plate <- replace(df_mirna_rs2$Plate, df_mirna_rs2$Sample.Name=="SP5006", 2)
df_mirna_rs2$Plate <- replace(df_mirna_rs2$Plate, df_mirna_rs2$Sample.Name=="SP5030", 4)
# Plot the corrections
plate1_repeat <- ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 1)%>%dplyr::filter(Welly == 5),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line()+ geom_point()+ylim(c(0, 120))+ ggtitle("Plate 1 Row 5")
plate2_hole <-ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 2)%>%dplyr::filter(Welly == 5),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line() + geom_point()+ylim(c(0, 120))+ ggtitle("Plate 2 Row 5")
plate2_repeat <- ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 2)%>%dplyr::filter(Welly == 3),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line()+ geom_point()+ylim(c(0, 120))+ ggtitle("Plate 2 Row 3")
plate4_hole <-ggplot(data = df_mirna_rs2%>%dplyr::filter(Plate == 4)%>%dplyr::filter(Welly == 3),
aes(x = Wellx, y = NameNumber, group = NameGroup, colour = NameGroup))+
geom_line() + geom_point()+ylim(c(0, 120))+ ggtitle("Plate 4 Row 3")
grid.arrange(plate1_repeat, plate2_hole ,plate2_repeat, plate4_hole, ncol=2, nrow=2)
#| label: fig-plateBoxplot
#| fig-cap: "miRNA quantity distribution sepparated by plate."
#| warning: false
bp1 <- ggplot(df_mirna_rs2, aes(x=as.factor(Plate), y=Quantity, fill=as.factor(Plate)))+
geom_boxplot()+ggtitle("Total miRNA Quantity distribution")+labs(x = "Plate")+
theme(legend.position="none")
bp2 <- ggplot(df_mirna_rs2, aes(x=as.factor(Plate), y=Quantity, fill=miRNA))+
geom_boxplot()+ggtitle("Specific miRNA Quantity distribution")+labs(x = "Plate", fill = "miRNA")
grid.arrange(bp1, bp2, ncol=2, nrow=1)
#| label: fig-pcaPlate
#| fig-cap: "PCA of the miRNA quantity."
#| warning: false
# We select the data of interest for the PCA.
# We now that each subject has the mirnas in the same plate except the samples that are stored in the plate 6 (we discard it).
# we also discard the samples which dont have all the data available in the 4 miRNAs.
df_mirna_pca <- na.omit(df_mirna)
df_mirna_pca2 <- df_mirna_pca %>%
dplyr::filter(Plate_mir100 != 6) %>%
dplyr::filter(Plate_mir16 != 6) %>%
dplyr::filter(Plate_mir486 != 6) %>%
dplyr::filter(Plate_mir92 != 6) %>%
dplyr::select(Sample.Name, date, Plate_mir100, tidyr::starts_with("Quantity"))
# Check that the different filters have work
c(length(df_mirna_pca$Sample.Name), length(df_mirna$Sample.Name), length(df_mirna_pca2$Sample.Name))
# Correct the wrong plate information
df_mirna_pca2$Plate_mir100 <- replace(df_mirna_pca2$Plate_mir100, df_mirna_pca2$Sample.Name == "SP5005", 2)
df_mirna_pca2$Plate_mir100 <- replace(df_mirna_pca2$Plate_mir100, df_mirna_pca2$Sample.Name=="SP5006", 2)
df_mirna_pca2$Plate_mir100 <- replace(df_mirna_pca2$Plate_mir100, df_mirna_pca2$Sample.Name=="SP5030", 4)
# Perform the PCA with the numeric data from the miRNAs
pca_mirna <- stats::prcomp(df_mirna_pca2 %>% dplyr::select(tidyr::starts_with("Quantity")), scale = TRUE)
# add the PCA results to the previous dataset
df_mirna_pca2 <- cbind(df_mirna_pca2, as.data.frame(pca_mirna$x))
# Plot the PCA divided by plates
a <- ggplot(df_mirna_pca2, aes(x=PC1, y=PC2))+
geom_point(aes(colour = factor(Plate_mir100)))+
ggtitle("PCA of miRNAs separated by Plate")+
labs(color = "Plate")
# Convert the date variable in a Date type variable
df_mirna_pca2$date <- as.Date(df_mirna_pca2$date, "%d-%m-%Y")
# Plot PCA painting the date of extraction
b <- ggplot(df_mirna_pca2, aes(x=PC1, y=PC2))+
geom_point(aes(colour = date))+
scale_color_gradient(low="blue", high="red")+
ggtitle("PCA of miRNAs separated by date")
# Plot both PCA together
grid.arrange(a , b, ncol=2, nrow=1)
#| label: fig-pcaName
#| fig-cap: "PCA of the miRNA quantity separated by ID names."
#| warning: false
# We separate the sample name by groups
df_mirna_pca2 <- df_mirna_pca2 %>%
dplyr::mutate(NameNumber = substr(Sample.Name , start = nchar(Sample.Name) - 2 , stop = nchar(Sample.Name)))%>%
dplyr::mutate(NameGroup = gsub('.{3}$', '', Sample.Name))
# Reset the class of the new variables
df_mirna_pca2$NameNumber <- as.numeric(df_mirna_pca2$NameNumber)
df_mirna_pca2$NameGroup <- as.factor(df_mirna_pca2$NameGroup)
# Plot the PCA separated by Sampl.Name
ggplot(df_mirna_pca2, aes(x=PC1, y=PC2))+
geom_point(aes(colour = NameNumber , shape = NameGroup), size = 3)+
scale_color_gradient(low="blue", high="red")+
ggtitle("PCA of miRNAs separated by ID")
#| label: fig-pca3D
#| fig-cap: "PCA of the miRNA quantity separated by ID names."
#| warning: false
library(plotly)
plot_ly(x = df_mirna_pca2$PC1, y = df_mirna_pca2$PC2, z = df_mirna_pca2$PC3, type = "scatter3d", mode = "markers", color = df_mirna_pca2$Plate)%>%
layout(title="PCA separated by Plate",
scene = list(xaxis = list(title = 'PC1'),
yaxis = list(title = 'PC2'),
zaxis = list(title = 'PC3')))
#| label: tbl-mirnaOutliers
#| tbl-cap: "PCA of the miRNA quantity without outliers."
#| warning: false
# Filtering the outliers
df_mirna_pca_new <- df_mirna_pca2 %>%
dplyr::filter(PC1 > -3.75)%>%
dplyr::select(-PC1,-PC2, -PC3, -PC4)
# Containing the info of outliers
df_mirna_outliers <- df_mirna_pca2 %>%
dplyr::filter(PC1 < -3.75) %>%
dplyr::select(Sample.Name, date, Plate_mir100)
kable(df_mirna_outliers)
#| label: fig-newpcaPlate
#| fig-cap: "PCA of the miRNA quantity without outliers."
#| warning: false
# Length comparison of the dataframe with and without the outliers
c(length(df_mirna_pca2$Sample.Name), length(df_mirna_pca_new$Sample.Name))
# Perform the PCA with the numeric data from the miRNAs
pca_mirna2 <- stats::prcomp(df_mirna_pca_new %>% dplyr::select(tidyr::starts_with("Quantity")), scale = TRUE)
# add the PCA results to the previous dataset
df_mirna_pca_new <- cbind(df_mirna_pca_new, as.data.frame(pca_mirna2$x))
ggplot(df_mirna_pca_new, aes(x=PC1, y=PC2))+
geom_point(aes(colour = factor(Plate_mir100)))+
ggtitle("New PCA of miRNAs separated by Plate")+
labs(color = "Plate")
# First we extract the outliers from the reshaped table
# Create identificator of the poutliers
id_outlier <- paste0(df_mirna_outliers$Sample.Name,
df_mirna_outliers$date,
df_mirna_outliers$Plate_mir100)
# Match the date variable type between both datasets
df_mirna_rs2$date <- as.Date(df_mirna_rs2$date, "%d-%m-%Y")
# Create the unique ID to remove the outliers from the dataset
df_mirna_rs3 <- df_mirna_rs2 %>%
dplyr::mutate(id_outlier = paste0(Sample.Name, date, Plate))
# Filter out rows with IDs in outlier_ids
df_mirna_rs3 <- df_mirna_rs3[!df_mirna_rs3$id_outlier %in% id_outlier, ]
c(length(df_mirna_rs2$Sample.Name), length(df_mirna_rs3$Sample.Name))
#| label: fig-QuantDif
#| fig-cap: "Quantity difference between miRNA duplicate samples."
#| warning: false
# Define a function to calculate the mean pairwise differences
mean_pairwise_diff <- function(values) {
if (length(values) == 2) {
return(c((values[1] - values[2])/sqrt(2), length(values)))
}
if (length(values) == 1){
return(c(NA, length(values)))
}
else {
# Calculate all pairwise combinations of differences
combn_diffs <- combn(values, 2, function(x) abs(x[1] - x[2])/sqrt(2))
return(c(mean(combn_diffs), length(values)))
}
}
# Apply the function to each miRNA (mir1 and mir2)
df_mirna_diff <- df_mirna_rs3 %>%
dplyr::group_by(Sample.Name, date, miRNA) %>%
dplyr::summarise(
diff = mean_pairwise_diff(Quantity)[1],
mn = mean(Quantity),
n = mean_pairwise_diff(Quantity)[2]
)
df_mirna_diff$miRNA <- as.factor(df_mirna_diff$miRNA)
a <- ggplot(df_mirna_diff, aes(x=mn, y=diff))+
geom_point(aes(colour = miRNA, shape = miRNA))+
ggtitle("Absolute difference")+
labs(x = "Quantity mean", y = "Quantity diff")
b <- ggplot(df_mirna_diff, aes(x=mn, y=diff/mn))+
geom_point(aes(colour = miRNA, shape = miRNA))+
# ylim(c(0, 1))+
ggtitle("Relative difference")+
labs(x = "Quantity mean", y = "Relative Quantity diference")
grid.arrange(a , b,  ncol=2, nrow=1)
View(df_mirna_rs3)
?measure_precision
tb_input <- df_mirna_rs3 %>%
dplyr::mutate(id = paste0(Sample.Name, date))%>%
dplyr::mutate(sensor = miRNA)%>%
dplyr::mutate(measurement = Quantity)
tb_input <- tb_input%>%
dplyr::select(id, sensor, measurement)
View(tb_input)
tb_out <- measure_precision(tb_input)
load_all(".")
rm(list = c("mean_pairwise_diff"))
load_all(".")
tb_out <- measure_precision(tb_input)
rm(list = c("mean_pairwise_diff"))
load_all(".")
tb_out <- measure_precision(tb_input)
tb_out
View(tb_out)
View(tb_out[[2]][[1]])
load_all(".")
tb_out <- measure_precision(tb_input)
tb_out$err <- tb_out$MAD
# Write the equation of the normalized value that would be used to calculate
norm_mir100_eq <- expression(mir100 / ((mir16 + mir92)/2))
tb_out2 <- error_propagation(tb_out, norm_mir100_eq)
error_propagation()
load_all(".")
error_propagation()
tb_out2 <- error_propagation(tb_out, norm_mir100_eq)
View(tb_out2)
View(tb_out[[2]][[1]])
library(devtools)
install_github("cyber-Ager/ImgOMIC")
library(ImgOMIC)
